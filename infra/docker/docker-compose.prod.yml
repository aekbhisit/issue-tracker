# ========================================
# Production Docker Compose
# For Issue Collector Platform
# ========================================
#
# TROUBLESHOOTING:
# If API container fails healthcheck, check logs:
#   docker logs issue-collector-api
#
# Common causes:
#   1. Missing required environment variables:
#      - JWT_SECRET (required in production, min 32 chars, unless SKIP_VALIDATION=1)
#      - SESSION_SECRET (required in production, min 32 chars, unless SKIP_VALIDATION=1)
#      - CORS_ORIGIN (optional - only affects browser CORS, not container startup)
#        Can use IP addresses if no domain: http://YOUR_IP:3400,http://YOUR_IP:3412
#   0. For initial container testing:
#      - Set SKIP_VALIDATION=1 to allow container to start without required env vars
#      - Empty strings for optional URLs are now accepted (will be treated as undefined)
#   2. Database connection issues (check postgres container logs)
#   3. Port conflicts (check if ports 3410, 3411, 3412 are already in use)
#   4. Logs directory permission issues:
#      - If you see "EACCES: permission denied, mkdir 'logs'" in logs:
#        The volume mount and command override should handle this, but if issues persist,
#        rebuild Harbor images with updated Dockerfile that includes logs directory creation
#
# ========================================

services:
  # PostgreSQL Database (with pgvector and PostGIS support)
  postgres:
    # Option 1: Use pre-built image from Harbor (recommended for Portainer)
    # Build and push image first: docker build -f infra/docker/postgres/Dockerfile.prod -t ${HARBOR_URL}/${HARBOR_PROJECT}/postgres-pgvector-postgis:17.6 infra/docker/postgres && docker push ${HARBOR_URL}/${HARBOR_PROJECT}/postgres-pgvector-postgis:17.6
    image: ${HARBOR_URL:-harbor-bo-bkk2.ndg-internal.com}/${HARBOR_PROJECT:-haahii}/postgres-pgvector-postgis:17.6
    # Option 2: Build from local context (for local development only - doesn't work in Portainer)
    # Uncomment below and comment image above if building locally
    # build:
    #   context: ./postgres
    #   dockerfile: Dockerfile.prod
    container_name: issue-collector-postgres
    environment:
      POSTGRES_USER: ${DATABASE_USER:-postgres}
      POSTGRES_PASSWORD: ${DATABASE_PASSWORD:-postgres}
      POSTGRES_DB: ${DATABASE_NAME:-issue_collector}
    volumes:
      - postgres_data:/var/lib/postgresql/data
      # Init scripts are included in the Docker image, so no volume mount needed
      # If you need custom init scripts, uncomment below and ensure path is accessible in Portainer
      # - ./postgres/initdb:/docker-entrypoint-initdb.d
    ports:
      # Expose PostgreSQL port for external connections (SSH tunnel, remote clients)
      # Access via: ssh -L 5436:localhost:5436 user@server
      # Using port 5436 to avoid conflict with existing PostgreSQL on host (default 5432)
      - "127.0.0.1:${DATABASE_PORT_EXTERNAL:-5436}:5432"  # Only bind to localhost for security
    healthcheck:
      # Check readiness via pg_isready so dependent services wait for DB availability.
      test: ["CMD-SHELL", "pg_isready -U ${DATABASE_USER:-postgres} -d ${DATABASE_NAME:-issue_collector}"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s
    restart: unless-stopped
    networks:
      - issue-collector-network

  # Redis Cache
  # Note: Redis is only used internally by containers, no external port mapping
  # to avoid conflict with existing Redis instance on host
  redis:
    image: redis:7-alpine
    container_name: issue-collector-redis
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data
    # No port mapping - only accessible within Docker network
    # Uncomment below if you need external access (change port to avoid conflict)
    # ports:
    #   - "${REDIS_PORT_EXTERNAL:-6380}:6379"
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s
    restart: unless-stopped
    networks:
      - issue-collector-network

  # API Backend
  api:
    image: ${HARBOR_URL:-harbor-bo-bkk2.ndg-internal.com}/${HARBOR_PROJECT:-haahii}/issue-collector-api:${IMAGE_TAG:-latest}
    container_name: issue-collector-api
    depends_on:
      # TEMPORARY: Changed from service_healthy to service_started to skip health checks for debugging
      # Change back to service_healthy after fixing issues
      postgres:
        condition: service_started
      redis:
        condition: service_started
    environment:
      # Application
      NODE_ENV: production
      API_PORT: 3410
      API_HOST: 0.0.0.0
      # Set NODE_PATH to allow Node.js to resolve modules from workspace root
      # This is needed because pnpm hoists dependencies to /app/node_modules
      # but we're running from /app/apps/api
      # Include both root and app-specific node_modules in case pnpm doesn't hoist
      NODE_PATH: /app/node_modules:/app/apps/api/node_modules
      # Set SKIP_VALIDATION=1 to allow container to start without required env vars (for initial testing only)
      SKIP_VALIDATION: ${SKIP_VALIDATION:-}

      # Database
      DATABASE_URL: postgresql://${DATABASE_USER:-postgres}:${DATABASE_PASSWORD:-postgres}@postgres:5432/${DATABASE_NAME:-issue_collector}
      DATABASE_HOST: postgres
      DATABASE_PORT: 5432
      DATABASE_NAME: ${DATABASE_NAME:-issue_collector}
      DATABASE_USER: ${DATABASE_USER:-postgres}
      DATABASE_PASSWORD: ${DATABASE_PASSWORD:-postgres}
      
      # Database Migration (Optional - set to 'true' to run migrations on startup)
      # âš ï¸ WARNING: Only enable for first deployment or when you want to auto-migrate
      # Set to 'true' for initial setup, then remove or set to 'false' for production
      RUN_MIGRATIONS_ON_STARTUP: ${RUN_MIGRATIONS_ON_STARTUP:-false}

      # Redis
      REDIS_URL: redis://redis:6379
      REDIS_HOST: redis
      REDIS_PORT: 6379

      # NOTE: OpenAI, RAG, and External API configurations have been REMOVED
      # These environment variables are NOT USED anywhere in the codebase
      # They were copied from another project but never implemented
      # If AI features are needed in the future (IC-9), add them back then

      # Security
      JWT_SECRET: ${JWT_SECRET}  # Required - minimum 32 characters
      JWT_ACCESS_EXPIRES_IN: ${JWT_ACCESS_EXPIRES_IN:-15m}
      JWT_REFRESH_EXPIRES_IN: ${JWT_REFRESH_EXPIRES_IN:-7d}
      SESSION_SECRET: ${SESSION_SECRET}  # Required - minimum 32 characters

      # CORS (Optional - only affects browser requests, NOT container startup)
      # CORS_ORIGIN controls which origins can make browser requests to the API
      # Containers will run fine without this - it only matters for browser CORS security
      # 
      # If you don't have a domain yet, you can:
      # 1. Leave it unset (uses default: localhost) - works for testing
      # 2. Use IP addresses: CORS_ORIGIN=http://192.168.1.100:3412,http://192.168.1.100:3411
      # 3. Production: CORS_ORIGIN=https://issue.haahii.com,https://issue.haahii.com/admin
      #
      # Note: This does NOT affect container startup or internal container-to-container communication
      # Must include both frontend (3412) and admin (3411) origins
      CORS_ORIGIN: ${CORS_ORIGIN:-http://localhost:3412,http://localhost:3411}

      # Logging
      LOG_LEVEL: ${LOG_LEVEL:-info}
      LOG_FORMAT: ${LOG_FORMAT:-json}

      # Monitoring (optional)
      SENTRY_DSN: ${SENTRY_DSN:-}

      # Upload
      UPLOAD_DIR: /app/uploads
      MAX_FILE_SIZE: ${MAX_FILE_SIZE:-10485760}

    volumes:
      - api_uploads:/app/storage
      - api_logs:/app/logs

    ports:
      - "${API_PORT:-3410}:3410"
    
    # Ensure logs directory exists before starting
    # This is a workaround for Harbor images that may not have the logs directory pre-created
    # The volume mount ensures the directory exists, but we create it explicitly to avoid permission issues
    # Note: Explicitly cd to /app/apps/api and verify path before running
    # IMPORTANT: Make sure Docker image is rebuilt with latest Dockerfile.prod
    # For permanent fix: Rebuild Harbor images with updated Dockerfile that creates /app/logs with proper permissions
    # Verify NODE_PATH and node_modules before starting
    command: ["sh", "-c", "mkdir -p /app/logs 2>/dev/null || true && echo 'ðŸ” Debugging module resolution...' && echo 'NODE_PATH='$NODE_PATH && echo 'Checking /app/node_modules:' && ls -la /app/node_modules/ 2>&1 | head -10 || echo 'No /app/node_modules' && echo 'Checking for dotenv:' && test -d /app/node_modules/dotenv && echo 'âœ… dotenv found' || echo 'âŒ dotenv NOT found' && echo 'Current directory:' && pwd && cd /app/apps/api && echo 'In /app/apps/api, checking dist:' && ls -la dist/ && echo 'Starting application...' && exec node dist/index.js"]

    # TEMPORARY: Health check disabled for debugging - uncomment after fixing issues
    # healthcheck:
    #   # Simple healthcheck - checks if /health endpoint returns 200
    #   # If healthcheck fails, check container logs: docker logs issue-collector-api
    #   # Common issues: Missing OPENAI_API_KEY, EXTERNAL_RAG_API_URL, JWT_SECRET, or SESSION_SECRET
    #   test: ["CMD", "node", "-e", "require('http').get('http://localhost:3410/health', (r) => process.exit(r.statusCode === 200 ? 0 : 1)).on('error', () => process.exit(1))"]
    #   interval: 30s
    #   timeout: 10s
    #   retries: 10
    #   start_period: 120s  # Increased to allow API to fully start and connect to DB

    restart: unless-stopped
    networks:
      - issue-collector-network

  # Admin Dashboard
  admin:
    image: ${HARBOR_URL:-harbor-bo-bkk2.ndg-internal.com}/${HARBOR_PROJECT:-haahii}/issue-collector-admin:${IMAGE_TAG:-latest}
    container_name: issue-collector-admin
    depends_on:
      # TEMPORARY: Changed from service_healthy to service_started to skip health checks for debugging
      # Change back to service_healthy after fixing issues
      api:
        condition: service_started
    environment:
      NODE_ENV: production
      PORT: 3411
      HOSTNAME: "0.0.0.0"
      
      # Admin API URL (âš ï¸ IMPORTANT)
      # For Docker internal networking: Use http://api:3410 (container-to-container)
      # For browser requests: Use public URL from NEXT_PUBLIC_ADMIN_API_URL env var
      # The admin code appends /api to this URL, so use base domain only
      # Production: https://issue.haahii.com (admin will call https://issue.haahii.com/api)
      NEXT_PUBLIC_ADMIN_API_URL: ${NEXT_PUBLIC_ADMIN_API_URL:-}
      
      # AI Chatbot Feature (Optional - Enable/disable AI chatbot in admin)
      # Set to "true" to enable AI chatbot features in admin dashboard
      # Set to "false" or leave empty to disable
      # âš ï¸ DISABLED: API endpoints not yet implemented
      NEXT_PUBLIC_ADMIN_AI_CHATBOT_ENABLED: ${NEXT_PUBLIC_ADMIN_AI_CHATBOT_ENABLED:-false}
      
      # Admin Asset Prefix (Optional - for static assets)
      # Set to '/admin' if using path-based routing (e.g., https://domain.com/admin)
      # Set to empty string if using subdomain-based routing (e.g., https://admin.domain.com)
      # This controls where Next.js static assets (_next/static) are loaded from
      NEXT_PUBLIC_ADMIN_ASSET_PREFIX: ${NEXT_PUBLIC_ADMIN_ASSET_PREFIX:-/admin}
      
      # Base path for route utilities and redirects
      NEXT_PUBLIC_ADMIN_BASE_PATH: ${NEXT_PUBLIC_ADMIN_BASE_PATH:-/admin}
      
      # Disable Next.js telemetry
      NEXT_TELEMETRY_DISABLED: 1
      # Set NODE_PATH for proper module resolution (matches Dockerfile.prod)
      # Include both root and admin node_modules for proper module resolution
      NODE_PATH: /app/node_modules:/app/apps/admin/node_modules
    ports:
      - "${ADMIN_PORT:-3411}:3411"
    # Override command to use node directly (avoids npx/pnpm exec downloading deps)
    # Check admin's node_modules first (where Next.js actually lives), then root as fallback
    # Path priority: /app/apps/admin/node_modules > /app/node_modules
    command: ["sh", "-c", "cd /app/apps/admin && if [ -L node_modules/.bin/next ] || [ -f node_modules/.bin/next ]; then exec node_modules/.bin/next start -p ${PORT:-3411}; elif [ -f node_modules/next/dist/bin/next ]; then exec node node_modules/next/dist/bin/next start -p ${PORT:-3411}; elif [ -L /app/node_modules/.bin/next ] || [ -f /app/node_modules/.bin/next ]; then exec /app/node_modules/.bin/next start -p ${PORT:-3411}; elif [ -f /app/node_modules/next/dist/bin/next ]; then exec node /app/node_modules/next/dist/bin/next start -p ${PORT:-3411}; else echo 'âŒ Next.js not found. Checking paths...' && echo 'Checking /app/apps/admin/node_modules/.bin/next:' && ls -la /app/apps/admin/node_modules/.bin/next 2>&1 || echo 'Not found' && echo 'Checking /app/apps/admin/node_modules/next/dist/bin/next:' && ls -la /app/apps/admin/node_modules/next/dist/bin/next 2>&1 || echo 'Not found' && echo 'Checking /app/node_modules/.bin/next:' && ls -la /app/node_modules/.bin/next 2>&1 || echo 'Not found' && echo 'Checking /app/node_modules/next/dist/bin/next:' && ls -la /app/node_modules/next/dist/bin/next 2>&1 || echo 'Not found' && echo 'Available Next.js locations:' && find /app -name 'next' -type d 2>/dev/null | head -10 && exit 1; fi"]
    # TEMPORARY: Health check disabled for debugging - uncomment after fixing issues
    # healthcheck:
    #   # Health check for admin Next.js app
    #   # Root path redirects to /login, so we check /login which returns 200
    #   # Alternative: Accept redirects (307/308) as healthy by checking statusCode < 400
    #   test: ["CMD", "node", "-e", "require('http').get('http://localhost:3411/login', (r) => {process.exit(r.statusCode === 200 ? 0 : 1)}).on('error', () => process.exit(1))"]
    #   interval: 30s
    #   timeout: 10s
    #   retries: 5
    #   start_period: 60s
    restart: unless-stopped
    networks:
      - issue-collector-network

  # Frontend App
  frontend:
    image: ${HARBOR_URL:-harbor-bo-bkk2.ndg-internal.com}/${HARBOR_PROJECT:-haahii}/issue-collector-frontend:${IMAGE_TAG:-latest}
    container_name: issue-collector-frontend
    depends_on:
      # TEMPORARY: Changed from service_healthy to service_started to skip health checks for debugging
      # Change back to service_healthy after fixing issues
      api:
        condition: service_started
    environment:
      NODE_ENV: production
      PORT: 3412
      HOSTNAME: "0.0.0.0"
      # Frontend API URL (âš ï¸ IMPORTANT)
      # For Docker internal networking: Use http://api:3410 (container-to-container)
      # For browser requests: Use public URL from NEXT_PUBLIC_FRONTEND_API_URL env var
      # The frontend code appends /api to this URL, so use base domain only
      # Production: https://issue.haahii.com (frontend will call https://issue.haahii.com/api)
      NEXT_PUBLIC_FRONTEND_API_URL: ${NEXT_PUBLIC_FRONTEND_API_URL:-http://api:3410}
    ports:
      - "${FRONTEND_PORT:-3412}:3412"
    # Override command to ensure Next.js is found (pnpm workspace hoisting issue)
    command: ["sh", "-c", "cd /app/apps/frontend && npx next start -p ${PORT:-3412}"]
    # TEMPORARY: Health check disabled for debugging - uncomment after fixing issues
    # healthcheck:
    #   test: ["CMD", "node", "-e", "require('http').get('http://localhost:3412/', (r) => {process.exit(r.statusCode === 200 ? 0 : 1)})"]
    #   interval: 30s
    #   timeout: 10s
    #   retries: 5
    #   start_period: 60s
    restart: unless-stopped
    networks:
      - issue-collector-network

volumes:
  postgres_data:
    driver: local
  redis_data:
    driver: local
  api_uploads:
    driver: local
  api_logs:
    driver: local

networks:
  issue-collector-network:
    driver: bridge
